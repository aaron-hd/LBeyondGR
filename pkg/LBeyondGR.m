(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



LBeyondGR`$Version = 0.1;
LBeyondGR`$Published = False;


Print@"========================================================================
LBeyondGR package is being loaded.
 =============================
version: last updated 26-Oct-2023
======================================================================="


<<MaTeX`
SetOptions[MaTeX, "Preamble" -> {"\\usepackage{lmodern,exscale}", "\\usepackage{amsmath,amssymb}", "\\usepackage{graphicx}"}]
SetOptions[MaTeX,FontSize->16];


BeginPackage["LBeyondGR`"];


Unprotect@@Names["LBeyondGR`*"];
ClearAll@@Names["LBeyondGR`*"];
Unprotect@@Names["LBeyondGR`Private`*"];
ClearAll@@Names["LBeyondGR`Private`*"];


$metric; $christoffel;
$t; $r; $\[Theta]; $\[Phi]; $v; $\[Chi];
$mass; $spin; $G0;
x; y; k; \[Lambda]; 


SetMetric::usage = 
"SetMetric[metricSymbol_Symbol]:: sets just the symbol of the metric which is to be used.\n
============================================================================================\n
SetMetric[metricSymbol, metricComponents, options:OptionsPattern[]]:: sets the metricSymbol and explicit metricComponents given as a List of dimension (4,4).\n
OPTIONS:\n
_______________________________________________________________________________\n
LowerQ->True (Specifies whether the user enters a metric with lower or upper indices. Standard Value is True, i.e., that the user enters with lower indices.";


GetMetric::usage = 
"GetMetric[]:: gets just the symbol of the metric which is currently declared.\n
============================================================================================\n
GetMetric[i,j]:: gets an explicit component (i,j) of the metric (or its inverse), where i and j have to be explicit indices, i.e., integers (-4,-3,-2,-1,1,2,3,4).";


SetBoyerLindquistCoords::usage = 
"SetCoordinates[t_Symbol, r_Symbol, \[Theta]_Symbol, \[Phi]_Symbol]:: sets the symbols to be used as BL coordinates.\n
============================================================================================
currently the camera is only set up for BL or Kerr coordinates!";

SetKerrCoords::usage = 
"SetCoordinates[v_Symbol, r_Symbol, \[Theta]_Symbol, \[Chi]_Symbolin]:: sets the list of symbols to be used as Kerr coordinates.\n
============================================================================================
currently the camera is only set up for BL or Kerr coordinates!";


GetBoyerLindquistCoords::usage = 
"GetBoyerLindquistCoords[]:: gets the list of symbols of the BL coordinates currently declared.\n
============================================================================================";

GetKerrCoords::usage = 
"GetKerrCoords[]:: gets the list of symbols of the Kerr coordinates currently declared.\n
============================================================================================";


SetMass::usage = 
"SetMass[mass_Symbol]:: sets the symbol that the user uses as the BH mass.\n
============================================================================================";

SetNewtonCoupling::usage = 
"SetMass[G0_Symbol]:: sets the symbol that the user uses as the the Newton coupling G0.\n
============================================================================================";

SetSpin::usage = 
"SetSpin[spin_Symbol]:: sets the symbol that the user uses as the BH spin.\n
============================================================================================";


SetChristoffel::usage = 
"SetChristoffel[christoffelSymbol_Symbol]:: sets just the symbol of the christoffel symbols which is to be used.\n
============================================================================================\n
SetChristoffel[christoffelSymbol, christoffelComponents, options:OptionsPattern[]]:: sets the christoffelSymbol and explicit christoffelComponents given as a List of dimension (4,4,4).\n
It only allows for input with one upper followed by two lower indices as the Christoffel is not a tensor.\n";


GetChristoffel::usage = 
"GetChristoffel[]:: gets just the symbol of the christoffel symbol which is currently declared.\n
============================================================================================\n
GetChristoffel[i,j,k]:: gets an explicit component (i,j,k) of the christoffel symbol, where i has to be an upper and j, k have to be lower indices, i.e., integers (1,2,3,4) and (-4,-3,-2,-1) respectively.";


GetNullGeodesic1stOrderODE::usage = 
"GetNullGeodesic1stOrderODE[]:: simply defines the lightlike geodesic equation as a 1st order system of 8 ODE's in terms of christoffel symbols with x as coordinates, k as wave-vectors and \[Lambda] as affine parameter.\n
Reference for implemented geodesic equation already cast into 1st order ODE: 1801.10452, Eq. (5) & (6).\n
============================================================================================\n
GetNullGeodesic1stOrderODE[pos, waveVector, affineParam]:: allows to define own notation for x, k and \[Lambda]";


GetBoyerLindquistInitialValues::usage = 
"GetBoyerLindquistInitialValues[{pos_Symbol, waveVector_Symbol, affineParam0_Symbol},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_]:: defines appropriate initial conditions for an incident ray on a specific screen point\n
{pos_, waveVector_, affineParam0_} are the desired symbols for the coordinates, the waveVector an the initial value for the affine parameter.\n
{rObs,\[Theta]Obs,\[Phi]Obs} defines the precise location of the screen w.r.t. Boyer-Lindquist coordinates of the BH.\n
{x_,y_} defines the screen coordinates of the specific image point.\n
a_ is the impact parameter.\n
The implemented formula's follow 1607.05767, Sec. II C."


ConvertBoyerLindquistToCartesian::usage = 
"ConvertBoyerLindquistToCartesian[{r_,\[Theta]_,\[Phi]_}]:: converts a set of BL coordinates into a set of spatial cartesian coordinates."


GetSingleLightRay::usage = 
"GetSingleLightRay[{rCam_,\[Theta]Cam_,\[Phi]Cam_},{xScreen_,yScreen_},paramRules_List]";


CheckConstantsOfMotionAlongRay::usage = 
"CheckConstantsOfMotionAlongRay[ray_,paramRules_]";


PlotSingleTrajectory::usage = 
"PlotSingleTrajectory[sol_, paramRules_List, opts:OptionsPattern[]]";


GetLensingBand::usage = 
"GetLensingBand[
	{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, 
	{{xCenterGuess_?RationalQ,yCenterGuess_?RationalQ}, {xOuterGuess_?RationalQ,yOuterGuess_?RationalQ}}, 
	paramRules_,
]:: determines any closed (potentially non-star-convex) lensing band boundary.";


GetPlotFrameLeft::usage = 
"GetPlotFrameLeft[
	plotRange_List/;Dimensions@plotRange==={2,2},
	opts:OptionsPattern[]
]:: generates a plot frame with axes left and bottom.";


GetPlotFrameRight::usage = 
"GetPlotFrameRight[
	plotRange_List/;Dimensions@plotRange==={2,2},
	opts:OptionsPattern[]
]:: generates a plot frame with axes left and bottom.";


GetPlotFrameMiddle::usage = 
"GetPlotFrameMiddle[
	plotRange_List/;Dimensions@plotRange==={2,2},
	opts:OptionsPattern[]
]:: generates a plot frame with axes left and bottom.";


GetLBRegion::usage =
"GetLBRegion[
	lbInner_List(*/;Dimensions@lbInner\[Equal]{_,2}*), 
	lbOuter_List(*/;Dimensions@lbInner\[Equal]{_,2}*),
	opts:OptionsPattern[]
]:: generates a lensing-band region (a ?Region object in Mathematica) from two discrete 2D lists of the inner and outer lensing-band boundaries.";


GetRangeOfRegion::usage =
"GetRangeOfRegion[reg_?RegionQ]:: determines the coordinate range which is covered by the region 'reg'.";


ShiftedAndRescaledRegion::usage = 
"ShiftedAndRescaledRegion[
	region_?RegionQ, 
	{x_?NumberQ,y_?NumberQ,s_?NumberQ}
]:: controid shift by (x,y) and rescaling by s of any given region.";


OverlayLensingBandsByHand::usage = 
"OverlayLensingBandsByHand[
	lbObs_,lbTheory_,
	opts:OptionsPattern[]
]:: generates a Dynamic environment to shift and rescale two lensing bands (or any Mathematica Region) lb1 and lb2 by hand.";


AreaOfDifference::usage = 
"AreaOfDifference[
	regToCover_?RegionQ, 
	regToRescale_?RegionQ, 
	{x_?NumberQ,y_?NumberQ,s_?NumberQ}
]:: determines the area of the part of regToCover which is not covered by regToRescale after controid shift by (x,y) and rescaling by s.";


GetMinimizedOverlap::usage = 
"GetMinimizedOverlap[
	LBexp_?RegionQ,
	params_List
]:: determines the (n=1) lensing band (via internal functions and user-provided 'params' which completely fix the spacetime) and minimizes the overlap with some observed/assumed lensed emission region 'LBexp'.";


PlotHorizon; PrintTemporaryOption; HorizonCondition;


WhichCoords; Kerr; BoyerLindquist;


UseShadowBoundaryForEntryPoint; ShowProgressPlot; MultipleOfEntryPoint; 
MaxNumberOfSteps; OutOfBoundsValue; WhichLensingBand; inner; outer; WhichLensingBandNumber;
InitialBisectionPrecision; InitialStepSize; MinStepSize; MaxBisectionPrecision;


NumberOfPolygonPoints;
ScaleRange; InitsXYS; LB1Color; LB2Color;


Begin["`Private`"];


(* ::Code::Initialization:: *)
(*a function to check whether something is an explicit index*)

ExplicitUpperIndexQ::usage = "ExplicitUpIndexQ[ind___] checks whether ind is an explicit upper index, i.e., if it is +1,+2,+3 or +4";

ExplicitUpperIndexQ[___] := False;
ExplicitUpperIndexQ[index_Integer/;1<=index<=4] := True;

ExplicitLowerIndexQ::usage = "ExplicitDownIndexQ[ind___] checks whether ind is an explicit lower index, i.e., if it is -1,-2,-3 or -4";

ExplicitLowerIndexQ[___] := False;
ExplicitLowerIndexQ[index_Integer/;-4<=index<=-1] := True;


RationalQ[___] := False;
RationalQ[a_?NumericQ/;Precision[a]===\[Infinity]] := True;


DynamicIterativeTaskTimeEstimatePrint[iterator_, iterativeTaskNumber_] := Module[
	{startTime},
	startTime = AbsoluteTime[];
	Print[
		"approx. ",
		Dynamic[DateDifference[DateList[startTime],DateList[startTime+((AbsoluteTime[] - startTime)/iterator*(iterativeTaskNumber - iterator))],{"Day","Hour","Minute","Second"}]],
		" left to finish calculation"
	];
];


SmoothHeaviside[r_,x_]:=(Tanh[x r]+1)/2;


GetMin$r[sol_]:=Module[
	{
		\[Lambda]Min = Head[sol[[1,-1]]][[1,1,1]],
		\[Lambda]Max = Head[sol[[1,-1]]][[1,1,2]]
	},
	Check[Minimize[{x[2][\[Lambda]]/.sol,\[Lambda]Min<\[Lambda]<\[Lambda]Max},\[Lambda]][[1]],None]
]


SetMass[mass_Symbol] := Module[
	{},
	$mass = mass;
];

SetNewtonCoupling[G0_Symbol] := Module[
	{},
	$G0 = G0;
];

SetSpin[spin_Symbol] := Module[
	{},
	$spin = spin;
];


SetBoyerLindquistCoords[t_Symbol, r_Symbol, \[Theta]_Symbol, \[Phi]_Symbol] := Module[
	{},
	WhichCoords = BoyerLindquist;
	$t = t;
	$r = r;
	$\[Theta] = \[Theta];
	$\[Phi] = \[Phi];
];

GetBoyerLindquistCoords[] := {$t, $r, $\[Theta], $\[Phi]};


(* ::Input::Initialization:: *)
SetKerrCoords[v_Symbol, r_Symbol, \[Theta]_Symbol, \[Chi]_Symbol] := Module[
	{},
  WhichCoords = Kerr;
	$v = v;
	$r = r;
	$\[Theta] = \[Theta];
	$\[Chi] = \[Chi];
];

GetKerrCoords[] := {$v, $r, $\[Theta], $\[Chi]};


(* sets just the symbol of the metric to be used *)
SetMetric[metricSymbol_Symbol] := Module[
	{},
	$metric = metricSymbol;
];

(* use lower metric components as the standard input form *)
(* TODO: user should actively decide on lower or upper declaration *)
Options[SetMetric] = {LowerQ->True};
SetMetric::LowerQBoole="The value of LowerQ should be True or False. User input overriden and standard value 'True' is used.";

(* sets symbol and explicit components of the metric to be used *)
SetMetric[metricSymbol_Symbol, metricComponents_List/;Dimensions[metricComponents]=={4,4}, options:OptionsPattern[]]:= Module[
	{
		inverseMetricComponents = Inverse[metricComponents]
	},
	
	(* set the metric symbol *)
	$metric = metricSymbol;

	Switch[OptionValue[LowerQ],
		True
		,
		(*set the lower metric*)
		Do[
			$metric[-i,-j]=metricComponents[[i,j]],
			{i,4},{j,4}
		];
		(*set the upper metric*)
		Do[
			$metric[i,j]=inverseMetricComponents[[i,j]],
			{i,4},{j,4}
		];
		,
		False
		,
		(*set the upper metric*)
		Do[
			$metric[i,j]=metricComponents[[i,j]],
			{i,4},{j,4}
		];
		(*set the lower metric*)
		Do[
			$metric[-i,-j]=inverseMetricComponents[[i,j]],
			{i,4},{j,4}
		];
		,
		___,
		Message[f::LowerQBoole,b];
		(*set the lower metric*)
		Do[
			$metric[-i,-j]=metricComponents[[i,j]],
			{i,4},{j,4}
		];
		(*set the upper metric*)
		Do[
			$metric[i,j]=inverseMetricComponents[[i,j]],
			{i,4},{j,4}
		];
	];
];


(* gets the (previously set) metric *)

GetMetric[] := $metric;

(* gets a specific component of the (previously set) metric *)
GetMetric[i_/;Or[ExplicitUpperIndexQ@i,ExplicitLowerIndexQ@i],j_/;Or[ExplicitUpperIndexQ@j,ExplicitLowerIndexQ@j]] := $metric[i,j];


(* ::Code::Initialization:: *)
(* sets just the christoffel symbol w/o explicit values *)
SetChristoffel[christoffelSymbol_] := Module[
	{},
	$christoffel = christoffelSymbol;
];

(* sets the christoffel symbol christoffelSymbol in xAct notation and assigns the values from a (4,4,4)-dimensional list christoffelList of expressions*)
(* it only allows for input with one upper followed by two lower indices as the Christoffel is not a tensor *)

SetChristoffel[christoffelSymbol_, christoffelComponents_List/;Dimensions[christoffelComponents]=={4,4,4}] := Module[
	{},

	$christoffel = christoffelSymbol;

	Do[
		$christoffel = christoffelSymbol;
		christoffelSymbol[i,-j,-k] = christoffelComponents[[i,j,k]],
		{i,4},{j,4},{k,4}
	];
];


(* gets the (previously set) metric *)

GetChristoffel[] := $christoffel;

(* gets a specific component of the (previously set) metric *)
GetChristoffel[i_?ExplicitUpperIndexQ, j_?ExplicitLowerIndexQ, k_?ExplicitLowerIndexQ] := $christoffel[i,j,k];


CalculateChristoffelsFromMetric[];


(*simply defines the geodesic equation as a 1st order system of 8 ODE's in terms of christoffel symbols*)
(*GetNullGeodesic1stOrderODE[pos_, waveVector_, affineParam_] where pos is the symbol for the position, waveVector the symbol for the wave vector, and affineParam the affine parameter of the null geodesic*)
(*Reference for implemented geodesic Eq. cast into 1st order ODE: 1801.10452, Eq. (5) & (6).*)

GetNullGeodesic1stOrderODE[] := GetNullGeodesic1stOrderODE[x, k, \[Lambda]];

GetNullGeodesic1stOrderODE[pos_Symbol, waveVector_Symbol, affineParam_Symbol] := Module[
	{},
	Return[{
		D[pos[1][affineParam],affineParam]==waveVector[1][affineParam], 
		D[pos[2][affineParam],affineParam]==waveVector[2][affineParam], 
		D[pos[3][affineParam],affineParam]==waveVector[3][affineParam], 
		D[pos[4][affineParam],affineParam]==waveVector[4][affineParam],
		D[waveVector[1][affineParam],affineParam]==-Sum[GetChristoffel[1,-m,-n]*waveVector[m][affineParam]*waveVector[n][affineParam],{m,4},{n,4}],
		D[waveVector[2][affineParam],affineParam]==-Sum[GetChristoffel[2,-m,-n]*waveVector[m][affineParam]*waveVector[n][affineParam],{m,4},{n,4}],
		D[waveVector[3][affineParam],affineParam]==-Sum[GetChristoffel[3,-m,-n]*waveVector[m][affineParam]*waveVector[n][affineParam],{m,4},{n,4}],
		D[waveVector[4][affineParam],affineParam]==-Sum[GetChristoffel[4,-m,-n]*waveVector[m][affineParam]*waveVector[n][affineParam],{m,4},{n,4}]
	}]
];


ConvertBoyerLindquistToCartesian[{r_,theta_,phi_}]:={Sqrt[r^2 + $spin^2]*Sin[theta]*Cos[phi], Sqrt[r^2 + $spin^2]*Sin[theta]*Sin[phi],r*Cos[theta]};


(*this is to transform the observers screen coordinates (i.e., the initial conditions for the light rays) into standard Boyer-Lindquist (BL) coordinates of the BH*)
(*we follow 1607.05767, Sec. II C*)
(*the observer screen extends in the observers x and y coordinates with the origin at (0,rObs,\[Theta]Obs,\[Phi]Obs) in BL-coords, while the observers z-axis is aligned with the radial direction in BL-coords*)
(*a is the rotation parameter of the Kerr-BH (0 for Schwarzschild) *)

(*TODO: could be hard-coded to decrease computation time*)

(*get the spatial coordinates*)
GetBoyerLindquistToSceenCoordsRule[{r_,\[Theta]_,\[Phi]_},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_] := Module[
	{\[Sigma],\[ScriptCapitalD],X,Y,Z},

	\[ScriptCapitalD] = Sin[\[Theta]Obs] Sqrt[rObs^2 + a^2] - y Cos[\[Theta]Obs];
	X = \[ScriptCapitalD] Cos[\[Phi]Obs] - x Sin[\[Phi]Obs];
	Y = \[ScriptCapitalD] Sin[\[Phi]Obs] + x Cos[\[Phi]Obs];
	Z = rObs Cos[\[Theta]Obs] + y Sin[\[Theta]Obs];
	\[Sigma] = (X^2 + Y^2 + Z^2 - a^2)/2;
	Return[{
		r ->  Sqrt[\[Sigma] + Sqrt[\[Sigma]^2 + a^2*Z^2]],
		\[Theta] -> ArcCos[Z/Sqrt[\[Sigma] + Sqrt[\[Sigma]^2 + a^2*Z^2]]],
		\[Phi] -> ArcTan[Y/X]
	}]
	
];

(*get the derivatives of the spatial coordinates*)
GetBoyerLindquistDerivativesToSceenCoordsRule[{r_,\[Theta]_,\[Phi]_},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_] := Module[
	{\[Sigma],\[ScriptCapitalD],X,Y,Z,\[CapitalSigma],\[ScriptCapitalR],\[CapitalPhi]},
	
	(*definitions to obtain initial position*)
	\[ScriptCapitalD] = Sin[\[Theta]Obs] Sqrt[rObs^2 + a^2] - y Cos[\[Theta]Obs];
	X = \[ScriptCapitalD] Cos[\[Phi]Obs] - x Sin[\[Phi]Obs];
	Y = \[ScriptCapitalD] Sin[\[Phi]Obs] + x Cos[\[Phi]Obs];
	Z = rObs Cos[\[Theta]Obs] + y Sin[\[Theta]Obs];
	\[Sigma] = (X^2 + Y^2 + Z^2 - a^2)/2;
	(*definitions to obtain initial velocity*)
	\[CapitalSigma] = (r^2 + a^2*Cos[\[Theta]]^2);
	\[ScriptCapitalR] = (Sqrt[r^2 + a^2])/.{r:>Sqrt[\[Sigma] + Sqrt[\[Sigma]^2 + a^2*Z^2]]};
	\[CapitalPhi] = (\[Phi]-\[Phi]Obs)/.{\[Phi]->ArcTan[Y/X]};
	Return[{
		Der[r] ->  -((r*\[ScriptCapitalR]*Sin[\[Theta]]*Sin[\[Theta]Obs]*Cos[\[CapitalPhi]] + \[ScriptCapitalR]^2*Cos[\[Theta]]*Cos[\[Theta]Obs])/\[CapitalSigma]),
		Der[\[Theta]] -> -((\[ScriptCapitalR]*Cos[\[Theta]]*Sin[\[Theta]Obs]*Cos[\[CapitalPhi]] - r*Sin[\[Theta]]*Cos[\[Theta]Obs])/\[CapitalSigma]),
		Der[\[Phi]] -> (Sin[\[Theta]Obs]*Sin[\[CapitalPhi]]*Csc[\[Theta]])/\[ScriptCapitalR]
	}]
	
];

(*returns the initial position *)
(*\[Delta] is a constant which in (-,+,+,+) signature is 0 for light-like particles (photons), -1 for others, cf. 1607.05767. Since we only work with photons for now we use \[Delta]=0*)
GetBoyerLindquistInitialValues[{pos_Symbol, waveVector_Symbol, affineParam0_},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_] := Module[
	{\[Beta], \[Gamma], covMetric = GetMetric[], xForSum, kForSum, \[Delta]=0, t=$t, r=$r, \[Theta]=$\[Theta], \[Phi]=$\[Phi]},

	xForSum = {None,r,\[Theta],\[Phi]};
	kForSum = {None,Der[r],Der[\[Theta]],Der[\[Phi]]};
	
	(*definitions to obtain initial time-component derivative*)
	\[Beta] = - (Sum[covMetric[-1,-i]*kForSum[[i]],{i,2,4}]/covMetric[-1,-1]);
	\[Gamma] = (\[Delta] - Sum[covMetric[-i,-j]*kForSum[[i]]*kForSum[[j]],{i,2,4},{j,2,4}])/covMetric[-1,-1];
	
	Return[{
		pos[1][affineParam0] == t,
		pos[2][affineParam0] == r,
		pos[3][affineParam0] == \[Theta],
		pos[4][affineParam0] == \[Phi],
		waveVector[1][affineParam0] == Der[t],
		waveVector[2][affineParam0] == Der[r],
		waveVector[3][affineParam0] == Der[\[Theta]],
		waveVector[4][affineParam0] == Der[\[Phi]]
	}/.{Der[t]-> \[Beta] + Sqrt[\[Beta]^2 + \[Gamma]], t->0}/.LBeyondGR`Private`GetBoyerLindquistDerivativesToSceenCoordsRule[{r,\[Theta],\[Phi]},{rObs,\[Theta]Obs,\[Phi]Obs},{x,y},a]/.LBeyondGR`Private`GetBoyerLindquistToSceenCoordsRule[{r,\[Theta],\[Phi]},{rObs,\[Theta]Obs,\[Phi]Obs},{x,y},a]]
]


(*this is to transform the standard Boyer-Lindquist (BL) coordinates of the BH into horizon-penetrating spherical ingoing Kerr (Kerr-Schild) coordinates*)
(*we follow Eq. (18-19) in 1811.04711*)

(*TODO: could be hard-coded to decrease computation time*)

GetKerrToBoyerLindquistCoordsRule[] := Module[
	{\[CapitalDelta] = $r^2 - 2 $G0 $mass $r + $spin^2},
	Return[{
		(*$r and $\[Theta] remain untransformed*)
		(*form from literature*)
		$v -> $t + $r + $G0 $mass Log[(-2 $G0 $mass $r+$r^2+$spin^2)/(4 $G0^2 $mass^2)]+($G0^2 $mass^2 Log[(-$G0 $mass+$r-Sqrt[$G0^2 $mass^2-$spin^2])/(-$G0 $mass+$r+Sqrt[$G0^2 $mass^2-$spin^2])])/Sqrt[$G0^2 $mass^2-$spin^2],
		Der[$v] -> Der[$t] + ($r^2+$spin^2)/(-2 $G0 $mass $r+$r^2+$spin^2) Der[$r],
		$\[Chi] -> $\[Phi] + $spin/(2Sqrt[$G0^2$mass^2 - $spin^2]) Log[($r-($mass+Sqrt[$G0^2$mass^2 - $spin^2]))/($r-($mass-Sqrt[$G0^2$mass^2 - $spin^2]))],
		Der[$\[Chi]] -> Der[$\[Phi]] + $spin/(-2 $G0 $mass $r+$r^2+$spin^2) Der[$r]
		(*self-determined form*)
		(*$v \[Rule] $t +$r+(2 $G0^2 $mass^2 ArcTan[(-$G0 $mass+$r)/Sqrt[-$G0^2 $mass^2+$spin^2]])/Sqrt[-$G0^2 $mass^2+$spin^2]+$G0 $mass Log[-2 $G0 $mass $r+$r^2+$spin^2],
		Der[$v] \[Rule] Der[$t] + ($r^2+$spin^2)/(-2 $G0 $mass $r+$r^2+$spin^2)Der[$r],
		$\[Chi] \[Rule] $\[Phi] +($spin ArcTan[(-$G0 $mass+$r)/Sqrt[-$G0^2 $mass^2+$spin^2]])/Sqrt[-$G0^2 $mass^2+$spin^2],
		Der[$\[Chi]] \[Rule] Der[$\[Phi]] + $spin/(-2 $G0 $mass $r+$r^2+$spin^2)Der[$r]*)
	}]
	
];

GetBoyerLindquistToKerrCoordsRule[] := Module[
	{\[CapitalDelta] = $r^2 - 2 $G0 $mass $r + $spin^2},
	Return[{
		(*$r and $\[Theta] remain untransformed*)
		(*form from literature*)
		$t -> $v - ($r+$G0 $mass Log[(-2 $G0 $mass $r+$r^2+$spin^2)/(4 $G0^2 $mass^2)]+($G0^2 $mass^2 Log[(-$G0 $mass+$r-Sqrt[$G0^2 $mass^2-$spin^2])/(-$G0 $mass+$r+Sqrt[$G0^2 $mass^2-$spin^2])])/Sqrt[$G0^2 $mass^2-$spin^2]),
		$\[Phi] -> $\[Chi] - $spin/(2Sqrt[$G0^2$mass^2 - $spin^2]) Log[($r-($mass+Sqrt[$G0^2$mass^2 - $spin^2]))/($r-($mass-Sqrt[$G0^2$mass^2 - $spin^2]))]
		(*self-determined form*)
		(*$t \[Rule] $v -$r-(2 $G0^2 $mass^2 ArcTan[(-$G0 $mass+$r)/Sqrt[-$G0^2 $mass^2+$spin^2]])/Sqrt[-$G0^2 $mass^2+$spin^2]-$G0 $mass Log[-2 $G0 $mass $r+$r^2+$spin^2],
		$\[Phi] \[Rule] $\[Chi] -($spin ArcTan[(-$G0 $mass+$r)/Sqrt[-$G0^2 $mass^2+$spin^2]])/Sqrt[-$G0^2 $mass^2+$spin^2]*)
	}]
	
];

(*there might be a more clever choice than t=0*)
GetKerrInitialValues[{pos_Symbol, waveVector_Symbol, affineParam0_},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_] := Module[
	{\[Beta], \[Gamma], covMetric = GetMetric[], xForSum, kForSum, \[Delta]=0, t=$t, r=$r, \[Theta]=$\[Theta], \[Phi]=$\[Phi], v=$v, \[Chi]=$\[Chi]},

	xForSum = {None,r,\[Theta],\[Phi]};
	kForSum = {None,Der[r],Der[\[Theta]],Der[\[Phi]]};
	
	(*definitions to obtain initial time-component derivative*)
	\[Beta] = - (Sum[covMetric[-1,-i]*kForSum[[i]],{i,2,4}]/covMetric[-1,-1]);
	\[Gamma] = (\[Delta] - Sum[covMetric[-i,-j]*kForSum[[i]]*kForSum[[j]],{i,2,4},{j,2,4}])/covMetric[-1,-1];
	
	Return[{
		pos[1][affineParam0] == v,
		pos[2][affineParam0] == r,
		pos[3][affineParam0] == \[Theta],
		pos[4][affineParam0] == \[Chi],
		waveVector[1][affineParam0] == \[Beta] + Sqrt[\[Beta]^2 + \[Gamma]],
		waveVector[2][affineParam0] == Der[r],
		waveVector[3][affineParam0] == Der[\[Theta]],
		waveVector[4][affineParam0] == Der[\[Chi]]
	}/.LBeyondGR`Private`GetKerrToBoyerLindquistCoordsRule[]/.{t->0}/.LBeyondGR`Private`GetBoyerLindquistDerivativesToSceenCoordsRule[{r,\[Theta],\[Phi]},{rObs,\[Theta]Obs,\[Phi]Obs},{x,y},a]/.LBeyondGR`Private`GetBoyerLindquistToSceenCoordsRule[{r,\[Theta],\[Phi]},{rObs,\[Theta]Obs,\[Phi]Obs},{x,y},a]]
]


(*TODO: check whether a=0 in GetBoyerLindquistInitialValues is an ok coordinate choice for any metric*)
(*TODO: could implement check that metric contains no symbols except for coordinates and those specified in paramRules*)
Options[GetSingleLightRay] := Join[Options[NDSolve],{HorizonCondition->False}];
Options[GetSingleLightRayBL] := Join[Options[NDSolve],{HorizonCondition->False}];
Options[GetSingleLightRayKerr] := Join[Options[NDSolve],{HorizonCondition->False}];

SetOptions[GetSingleLightRay, WorkingPrecision->20];
SetOptions[GetSingleLightRayBL, WorkingPrecision->20];
SetOptions[GetSingleLightRayKerr, WorkingPrecision->20];

GetSingleLightRay[{rCam_,\[Theta]Cam_,\[Phi]Cam_},{xScreen_,yScreen_},paramRules_List, opts:OptionsPattern[]] := Module[{},
	Print["Input values of {rCam_,\[Theta]Cam_,\[Phi]Cam_} and/or {xScreen_,yScreen_} not recognized as infinite precision numbers. 
Please use rational input only as this improves the employed numerical methods. 
You can use Rationalize[input_,precision_]] where precision is the desired precision, e.g., 10^-100, to rationalize your numerical input."
	]
];

GetSingleLightRay[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ},{xScreen_?RationalQ,yScreen_?RationalQ},paramRules_List, opts:OptionsPattern[]] := Module[
	{},
	Switch[
		(*condition*)
		WhichCoords,
		(*option 1*)
		BoyerLindquist,
		Return[GetSingleLightRayBL[{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},paramRules, opts]],
		(*option 2*)
		Kerr,
		Return[GetSingleLightRayKerr[{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},paramRules, opts]],
		(*default other*)
		_,
		Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];
		Return[Null]		
	]
]


GetSingleLightRayBL[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ},{xScreen_?RationalQ,yScreen_?RationalQ},paramRules_List, opts:OptionsPattern[]] := Module[
	{
		return = None,
		(*workingPrecision = OptionValue[WorkingPrecision],*)
		inits = GetBoyerLindquistInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},$spin]/.Rationalize[paramRules,10^-100], 
		odes = Join[
			GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100]
		], 
		\[Lambda]Max= 3rCam
	},
	
	return = (*Check[*)
		Catch[NDSolve[
			Join[odes, inits],
			{x[1][\[Lambda]],x[2][\[Lambda]],x[3][\[Lambda]],x[4][\[Lambda]],k[1][\[Lambda]],k[2][\[Lambda]],k[3][\[Lambda]],k[4][\[Lambda]]},{\[Lambda],0,\[Lambda]Max},
			Method -> {
				"EventLocator", 
				"Event" -> {
					x[2][\[Lambda]]>rCam*11/10,
					If[TrueQ[!OptionValue[HorizonCondition]],
						(Evaluate[Abs[1/GetMetric[2,2]/.Rationalize[paramRules,10^-100]]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]})>10^2(*(workingPrecision/10)*),
						(Evaluate[(OptionValue[HorizonCondition])/.Rationalize[paramRules,10^-100]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]})
					]
				}, 
				"EventAction" :> {
					(Print["trajectory escapes: at \[Lambda]="<>ToString[N[\[Lambda],5]]<>" the radial coordinate has surpassed the radial camera distance"]; 
					Throw[Null,"StopIntegration"])
					,
					If[
						TrueQ[!OptionValue[HorizonCondition]]
						,
						Print["trajectory fell into Killing horizon: at \[Lambda]=",N[\[Lambda],5]," the 1/\!\(\*SuperscriptBox[\(g\), \(rr\)]\) has surpassed 10^",2(*N[workingPrecision/10]*)," (chosen at rather random value). 
						If the event and Killing horizon differ, the user may pass on a horizon-condition $r($\[Theta]) via the option HorizonCondition->___.
						Also, note that very extreme spacetimes may have FALSELY been interpreted as a Killing horizon.
						Similarly, if the MaxStepSize is too large horizons may have not been detected."]; 
						,
						Print["trajectory fell into user defined horizon condition: at \[Lambda]=",N[\[Lambda],5],". Note that if the MaxStepSize is too large horizons may have not been detected. If in doubt, please check decreased MaxStepSize and ensure convergence."]
					];
					Throw[Null,"StopIntegration"]
				}
			},
			Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[NDSolve][[All,1]],optName]]](*WorkingPrecision\[Rule]workingPrecision, MaxSteps\[Rule]1000000*)
		]](*,
		None
	]*);
	Return@return;
];


GetSingleLightRayKerr[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ},{xScreen_?RationalQ,yScreen_?RationalQ},paramRules_List, opts:OptionsPattern[]] := Module[
	{
		return = None,
		inits = GetKerrInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},$spin]/.Rationalize[paramRules,10^-100], 
		odes = Join[
			GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100]
		], 
		\[Lambda]Max= 3rCam
	},
	
	return = (*Check[*)
		Catch[NDSolve[
			Join[odes, inits],
			{x[1][\[Lambda]],x[2][\[Lambda]],x[3][\[Lambda]],x[4][\[Lambda]],k[1][\[Lambda]],k[2][\[Lambda]],k[3][\[Lambda]],k[4][\[Lambda]]},{\[Lambda],0,\[Lambda]Max},
			Method -> {
				"EventLocator", 
				"Event" -> {
					x[2][\[Lambda]]>rCam*11/10,
					If[TrueQ[!OptionValue[HorizonCondition]],
						(Evaluate[Abs[1/GetMetric[2,2]/.Rationalize[paramRules,10^-100]]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})>10^2(*(workingPrecision/10)*),
						(Evaluate[(OptionValue[HorizonCondition])/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})
					]
				}, 
				"EventAction" :> {
					(Print["trajectory escapes: at \[Lambda]="<>ToString[N[\[Lambda],5]]<>" the radial coordinate has surpassed the radial camera distance"]; 
					Throw[Null,"StopIntegration"])
					,
					If[
						TrueQ[!OptionValue[HorizonCondition]]
						,
						Print["trajectory fell into Killing horizon: at \[Lambda]=",N[\[Lambda],5]," the 1/\!\(\*SuperscriptBox[\(g\), \(rr\)]\) has surpassed 10^",2(*N[workingPrecision/10]*)," (chosen at rather random value). 
						If the event and Killing horizon differ, the user may pass on a horizon-condition $r($\[Theta]) via the option HorizonCondition->___.
						Also, note that very extreme spacetimes may have FALSELY been interpreted as a Killing horizon.
						Similarly, if the MaxStepSize is too large horizons may have not been detected."]; 
						,
						Print["trajectory fell into user defined horizon condition: at \[Lambda]=",N[\[Lambda],5],". Note that if the MaxStepSize is too large horizons may have not been detected. If in doubt, please check decreased MaxStepSize and ensure convergence."]
					];
					Throw[Null,"StopIntegration"]
				}
			},
			Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[NDSolve][[All,1]],optName]]](*MaxStepSize\[Rule]1*^-2, MaxSteps\[Rule]1000000*)
		]](*,
		None
	]*);
	Return@return;
];


TrajectoryQ[___] := False;
TrajectoryQ[{
	x[1][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	x[2][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	x[3][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	x[4][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	k[1][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	k[2][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	k[3][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	k[4][\[Lambda]]->InterpolatingFunction[___][\[Lambda]]
}] := True;

Options[PlotSingleTrajectory] := Join[Options[ParametricPlot3D],{PlotHorizon->False}];

PlotSingleTrajectory[sol_?TrajectoryQ, paramRules_List, opts:OptionsPattern[]] := Module[
	{
		plot,
		plotRangeVal,
		horizonCondition,
		xCartesian,yCartesian,zCartesian
	},
	(*determine a useful plot range unless user has passed their own*)
	If[
		OptionValue[PlotRange]===Automatic
		,
		Print["plot range obtained by doubling the radial distance at which angular coordinate \[Theta] changes most rapidly: use PlotRange option to set own plot range."];
		plotRangeVal = x[2][\[Lambda]]/.sol/.Last[Check[NMaximize[Evaluate[D[x[3][\[Lambda]]/.sol,\[Lambda]]],{\[Lambda],Head[sol[[3,2]]][[1,1,1]],Head[sol[[3,2]]][[1,1,2]]}],{None,{\[Lambda]->Head[sol[[3,2]]][[1,1,2]]}}]];
		plotRangeVal = Evaluate[{{-2,2},{-2,2},{-2,2}}plotRangeVal];
		,
		plotRangeVal = OptionValue[PlotRange];
	];

	(*create main plot of trajectory*)
	plot = ParametricPlot3D[
		Evaluate[ConvertBoyerLindquistToCartesian[{$r,$\[Theta],$\[Phi]}]//.Switch[
				WhichCoords,
				BoyerLindquist, {$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]},
				Kerr, Join[GetBoyerLindquistToKerrCoordsRule[],{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}],
				_,Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];Break[];
			]/.paramRules/.sol],{\[Lambda],0,Head[sol[[1,-1]]][[1,1,-1]]},
		opts,
		PlotRange->plotRangeVal,
		PlotStyle->{Thick,Red}, PlotPoints->5000,
		AxesLabel->{"x", "y", "z"}, LabelStyle->{Black,16,FontFamily->"Helvetica"}, BoxStyle->Directive[{Black,Thick}]
	];

	(*plot horizon if user wants to*)
	Switch[
		OptionValue[PlotHorizon]
		,
		False
		,
		None;
		,
		_Graphics3D
		,
		plot = Show[
			plot, 
			OptionValue[PlotHorizon]
		];
		,
		True
		,
		PrintTemporary["PlotHorizon: horizon is determined numerically using 500 points at random angles to approximate a surface solving 1/\!\(\*SubscriptBox[\(g\), \(tt\)]\)==0 (might not be the generic horizon). You can change the number of points via PlotHorizon->numberOfPoints."];
		PrintTemporary["Alternatively, you can pass the horizon as a Graphics3D object, or predetermine the horizon via sol=NumericalHorizonSurfacePlot3D[paramRules_List, numberOfPoints_] and pass the result via PlotHorizon->sol."];
		plot = Show[
			plot, 
			LBeyondGR`Private`NumericalHorizonSurfacePlot3D[paramRules, 500]
		];
		,
		_Integer
		,
		PrintTemporary["PlotHorizon: horizon is determined numerically using "<>ToString@OptionValue[PlotHorizon]<>" points at random angles to approximate a surface solving 1/\!\(\*SubscriptBox[\(g\), \(tt\)]\)==0 (might not be the generic horizon)."];
		PrintTemporary["Alternatively, you can pass the horizon as a Graphics3D object, or predetermine the horizon via sol=NumericalHorizonSurfacePlot3D[paramRules_List, numberOfPoints_] and pass the result via PlotHorizon->sol."];
		plot = Show[
			plot, 
			LBeyondGR`Private`NumericalHorizonSurfacePlot3D[paramRules, OptionValue[PlotHorizon]]
		];
		,
		___
		,
		Print["PlotHorizon: no proper option value given. Please use True, False, an integer number of numerical horizon plot points, or a Graphics3D object"]
	];

	Return@plot;
];

PlotSingleTrajectory[sol_, paramRules_List, opts:OptionsPattern[]] := Module[{},
	Print["Looks like you input value for 'sol' is not a trajectory as generated by GetSingleLightRay[].
Please use the latter to generate a trajectory before attempting to plot."]
];

NumericalHorizonSurfacePlot3D[paramRules_List, numberOfPoints_]:=Module[
	{
		guess  = {$\[Theta]->\[Pi]/2,$\[Phi]->\[Pi],$r->Max[Join[{0.01},($r/.#)&/@Quiet@NSolve[(1/GetMetric[1,1]==0)/.paramRules/.{$\[Theta]->\[Pi]/2,$\[Phi]->\[Pi]/2},$r,Reals]]]}//N,
		discreteHorizonData,
		return,
		outermostGuess = 100,
		r=$r, \[Theta]=$\[Theta], \[Phi]=$\[Phi], aaa
	},
	Print@guess;
	
	DynamicModule[
		{
			counter=0,
			starttime = AbsoluteTime[]
		},
	
		PrintTemporary["determining plot points for numerical horizon ... "];
		PrintTemporary["estimated remaining time for evaluation: ", Dynamic[DateDifference[DateList[starttime],DateList[starttime+((AbsoluteTime[] - starttime)/counter*(numberOfPoints - counter))],{"Day","Hour","Minute","Second"}]]];

		discreteHorizonData = Join[#,
				counter=counter+1;
				FindRoot[
					Evaluate[Simplify[1/GetMetric[1,1]/.paramRules/.$r->aaa]/.#],{aaa,guess[[3,2]],outermostGuess}
				]
			]&/@Table[{\[Theta]->RandomReal[{0,\[Pi]}], \[Phi]->RandomReal[{0,2\[Pi]}]},{count,numberOfPoints}];
	];

	discreteHorizonData = ({aaa*Sin[\[Theta]]Cos[\[Phi]],aaa*Sin[\[Theta]]Sin[\[Phi]],aaa*Cos[\[Theta]]}/.#)&/@discreteHorizonData;
	
	return = ListSurfacePlot3D[discreteHorizonData, PlotStyle->Directive[Black]];
	Return@return;
]


CheckConstantsOfMotionAlongRay[ray_,paramRules_,angMomVar_] := Module[
	{
		\[Lambda]Min= Head[ray[[1,2]]][[1,1,1]],
		\[Lambda]Max= Head[ray[[1,2]]][[1,1,2]],
		energy = Simplify[
				-Sum[GetMetric[-1,-j]k[j][\[Lambda]],{j,1,4}]/.paramRules,
				Trig->False
			]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.ray,
		angularMomentum = Simplify[
				Sum[GetMetric[-4,-j]k[j][\[Lambda]],{j,1,4}]/.paramRules,
				Trig->False
			]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.ray,
		carterConst = Simplify[
				(
					+ Sum[GetMetric[-3,-j]k[j][\[Lambda]],{j,1,4}]^2
					+ Cos[x[3][\[Lambda]]]^2(
						- angMomVar^2*(Sum[GetMetric[-1,-j]k[j][\[Lambda]],{j,1,4}]^2)
						+ (Sum[GetMetric[-4,-j]k[j][\[Lambda]],{j,1,4}]^2)/(Sin[x[3][\[Lambda]]]^2)
						)
				)/.paramRules,
				Trig->False
			]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.ray,
		relativeErrorEnergy, relativeErrorAngularMomentum, relativeErrorCarterConstant
	},
	relativeErrorEnergy = If[(energy/.\[Lambda]->RandomReal[{\[Lambda]Min,\[Lambda]Max}]) == 0, 0, ((energy/.\[Lambda]->\[Lambda]Min) - (energy))/(energy/.\[Lambda]->\[Lambda]Min)];
	relativeErrorAngularMomentum = If[(angularMomentum/.\[Lambda]->RandomReal[{\[Lambda]Min,\[Lambda]Max}]) == 0, 0, ((angularMomentum/.\[Lambda]->\[Lambda]Min) - (angularMomentum))/(angularMomentum/.\[Lambda]->\[Lambda]Min)];
	relativeErrorCarterConstant = If[(carterConst/.\[Lambda]->RandomReal[{\[Lambda]Min,\[Lambda]Max}]) == 0, 0, ((carterConst/.\[Lambda]->\[Lambda]Min) - (carterConst))/(carterConst/.\[Lambda]->\[Lambda]Min)];
	
	If[relativeErrorEnergy === 0,
		Print["energy seems to vanish identically"];
		,
		Print@LogPlot[
			Evaluate[{Abs[energy],Abs[relativeErrorEnergy]}],
			{\[Lambda],\[Lambda]Min,\[Lambda]Max}, PlotRange->Full,
			PlotStyle->{{Thick,Red},{Dashed,Red}}, AspectRatio->1,ImageSize->350,
			Frame->True,PlotLabel->"energy",FrameLabel->{"affine parameter \[Lambda]","energy [relative error]"},LabelStyle->{Black,16},FrameStyle->{{Thick,Black}}
		];
	];
	
	If[relativeErrorAngularMomentum === 0,
		Print["angular momentum seems to vanish identically"];
		,
		Print@LogPlot[
			Evaluate[{Abs[angularMomentum],Abs[relativeErrorAngularMomentum]}],
			{\[Lambda],\[Lambda]Min,\[Lambda]Max},PlotRange->Full,
			PlotStyle->{{Thick,Red},{Dashed,Red}}, AspectRatio->1,ImageSize->350,
			Frame->True,PlotLabel->"angular momentum",FrameLabel->{"affine parameter \[Lambda]", "momentum [relative error]"},LabelStyle->{Black,16},FrameStyle->{{Thick,Black}}
		];
	];
	
	If[relativeErrorCarterConstant === 0,
		Print["Carter constant seems to vanish identically"];
		,
		Print@LogPlot[
			Evaluate[{Abs[carterConst],Abs[relativeErrorCarterConstant]}],
			{\[Lambda],\[Lambda]Min,\[Lambda]Max}, PlotRange->Full,
			PlotStyle->{{Thick,Red},{Dashed,Red}}, AspectRatio->1,ImageSize->350,
			Frame->True,PlotLabel->"Carter constant",FrameLabel->{"affine parameter \[Lambda]","Carter [relative error]"},LabelStyle->{Black,16},FrameStyle->{{Thick,Black}}
		];
	];

	{
		{"maximalErrors", NMaxValue[{Abs[relativeErrorEnergy],\[Lambda]Min<\[Lambda]<\[Lambda]Max},\[Lambda]], NMaxValue[{Abs[relativeErrorAngularMomentum],\[Lambda]Min<\[Lambda]<\[Lambda]Max},\[Lambda]], NMaxValue[{Abs[relativeErrorCarterConstant],\[Lambda]Min<\[Lambda]<\[Lambda]Max},\[Lambda]]},
		{"finalTimeErrors", Abs[relativeErrorEnergy/.{\[Lambda]->\[Lambda]Max}], Abs[relativeErrorAngularMomentum/.{\[Lambda]->\[Lambda]Max}], Abs[relativeErrorCarterConstant/.{\[Lambda]->\[Lambda]Max}]}
	}
]


Options[BoundaryBisectionInternal] := Options[BoundaryBisection];

BoundaryBisectionInternal::HorizonCondition="Trajectory fell into user-defined horizon.";

BoundaryBisectionInternal[odes_, inits_, {\[Lambda]_,\[Lambda]Min_,\[Lambda]Max_}, {xScreen_, yScreen_}, {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		sol,
		stepNumber = 0
	},
	
	(*Print[OptionValue[WorkingPrecision]];*)
	
	If[OptionValue[PrintTemporaryOption], 
		PrintTemporary["current bisection: x \[Element] ["<>ToString[N@xInnerScreen]<>","<>ToString[N@xOuterScreen]<>"] and y \[Element] [", N@yInnerScreen, ", ", N@yOuterScreen, "]."];
	];
	If[
		(xOuterScreen-xInnerScreen)^2 + (yOuterScreen-yInnerScreen)^2 > precisionAim^2
		,
		(*Print@If[TrueQ[!OptionValue[HorizonCondition]],"proceed without horizon condition", "apply horizon condition", "other"];*)
		sol = Check[
			Catch[NDSolve[
				Join[
					odes,
					inits/.{xScreen -> xInnerScreen + (xOuterScreen-xInnerScreen)/2, yScreen -> yInnerScreen + (yOuterScreen-yInnerScreen)/2}
				],
				{x[1][\[Lambda]],x[2][\[Lambda]],x[3][\[Lambda]],x[4][\[Lambda]],k[1][\[Lambda]],k[2][\[Lambda]],k[3][\[Lambda]],k[4][\[Lambda]]},{\[Lambda],\[Lambda]Min,\[Lambda]Max},
				Method -> If[
					TrueQ[!OptionValue[HorizonCondition]],
					Automatic,
					{
						"EventLocator", 
						"Event" -> {
							(Evaluate[(OptionValue[HorizonCondition])/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})
						}, 
						"EventAction" :> {
							(If[OptionValue[PrintTemporaryOption],PrintTemporary[
								"trajectory fell into user-defined horizon: at \[Lambda]="<>ToString[N[\[Lambda],5]]<>" the user-defined HorizonCondition has been numerically detected.",
								"Note that this essentially detects the observers image of the user-defined surface 'HorizonCondition'."
							]];
							Message[BoundaryBisectionInternal::HorizonCondition];
							Throw[Null,"StopIntegration"])
						}
					}
				],
				Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[NDSolve][[All,1]],optName]]], MaxSteps->OptionValue[MaxSteps]
			]],
			Null
		];
		(*PrintTemporary@If[sol===Null||Head@sol===String,"fell into","passed \[Infinity]"];*)
		If[
			sol===Null||Head@sol===String,
			BoundaryBisectionInternal[odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen + (xOuterScreen-xInnerScreen)/2,yInnerScreen + (yOuterScreen-yInnerScreen)/2}, {xOuterScreen,yOuterScreen}}, paramRules, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]],
			BoundaryBisectionInternal[odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen,yInnerScreen}, {xInnerScreen + (xOuterScreen-xInnerScreen)/2,yInnerScreen + (yOuterScreen-yInnerScreen)/2}}, paramRules, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]]
		]
		,
		Return[N[{xOuterScreen(*xInnerScreen + (xOuterScreen-xInnerScreen)/2*), yOuterScreen(*yInnerScreen + (yOuterScreen-yInnerScreen)/2*)}]],
		None
	]
];


Options[BoundaryBisection] := Join[{PrintTemporaryOption->True, HorizonCondition->False},Options[NDSolve]];

BoundaryBisection[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, {{xInnerScreen_?RationalQ,yInnerScreen_?RationalQ}, {xOuterScreen_?RationalQ,yOuterScreen_?RationalQ}}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		inits, xScreen, yScreen,odes,
		\[Lambda]Max= 3rCam,
		result, return
	},
	
	Switch[
		(*condition*)
		WhichCoords,
		(*option 1*)
		BoyerLindquist,
		odes = GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100];
		inits = GetBoyerLindquistInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},0]/.Rationalize[paramRules,10^-100];
		,
		(*option 2*)
		Kerr,
		odes = GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100];
		inits = GetKerrInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},$spin]/.Rationalize[paramRules,10^-100];
		,
		(*default other*)
		_,
		Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];
		Return[Null]		
	];
	
	If[OptionValue[PrintTemporaryOption], PrintTemporary["boundary bisection in progress ... using ",If[TrueQ[!OptionValue[HorizonCondition]],"any NDSolve error as indication for a ray falling into the horizon", "NDSolve errors and/or the user specified HorizonCondition as indication for a ray falling into the horizon"]]];
	result = BoundaryBisectionInternal[odes, inits, {\[Lambda],0,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen,yInnerScreen}, {xOuterScreen,yOuterScreen}}, paramRules, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]];

	If[
		Or[
			(xOuterScreen - result[[1]])^2 + (yOuterScreen - result[[2]])^2 < 2*precisionAim^2,
			(xInnerScreen - result[[1]])^2 + (yInnerScreen - result[[2]])^2 < 2*precisionAim^2
		]
		,
		If[OptionValue[PrintTemporaryOption], Print["probably no shadow boundary between the two specified points."]];
		return = None;
		,
		If[OptionValue[PrintTemporaryOption], Print["shadow boundary was found within the specified interval."]];
		return = result;
	];

	Return@return;
];

BoundaryBisection[{rCam_,\[Theta]Cam_,\[Phi]Cam_}, {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[{},
	Print["Input values of {rCam_,\[Theta]Cam_,\[Phi]Cam_} and/or {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}} not recognized as infinite precision numbers. 
Please use rational input only as this improves the employed numerical methods. 
You can use Rationalize[input_,precision_]] where precision is the desired precision, e.g., 10^-100, to rationalize your numerical input."
	];
];


Options[GetParametricShadowBoundary] := DeleteDuplicates@Join[{HorizonCondition->False},Options[BoundaryBisection]];

GetParametricShadowBoundary[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, {xCenter_?RationalQ,yCenter_?RationalQ}, radialSweepDistance_?RationalQ, {\[Psi]min_?RationalQ,\[Psi]max_?RationalQ,\[Psi]stepSize_?RationalQ}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		\[Psi]table = Table[\[Psi]Val,{\[Psi]Val,\[Psi]min,\[Psi]max,\[Psi]stepSize}],
		return
	},
	
	DynamicModule[
		{
			counter=0,
			starttime = AbsoluteTime[],
			printValue1
		},
	
		PrintTemporary["boundary bisection in progress ... for image angle \[Psi]=", Dynamic[N@printValue1]];
		PrintTemporary["estimated remaining time for evaluation: ", Dynamic[DateDifference[DateList[starttime],DateList[starttime+((AbsoluteTime[] - starttime)/counter*(Length@\[Psi]table - counter))],{"Day","Hour","Minute","Second"}]]];

		return = {
			printValue1=#;
			counter = counter + 1;
			#,
			BoundaryBisection[
				{rCam,\[Theta]Cam,\[Phi]Cam},
				{{xCenter,yCenter}, Rationalize[N[{xCenter + Cos[#]*radialSweepDistance, yCenter + Sin[#]*radialSweepDistance},100],10^-100]}, 
				paramRules, 
				precisionAim,
				PrintTemporaryOption->False,
				opts
			]
		}&/@\[Psi]table;
	];

	return = {{N[#[[1]]],Sqrt[(#[[2,1]]-xCenter)^2 +  (#[[2,2]]-yCenter)^2]},#[[2]]}&/@return;
	
	Return@return;
];

GetParametricShadowBoundary[{rCam_,\[Theta]Cam_,\[Phi]Cam_}, {xCenter_,yCenter_}, radialSweepDistance_, {\[Psi]min_,\[Psi]max_,\[Psi]stepSize_}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[{},
	Print["Input values of {rCam_,\[Theta]Cam_,\[Phi]Cam_}, radialSweepDistance, {xCenter_,yCenter_}, and/or {\[Psi]min_,\[Psi]max_,\[Psi]stepSize_} not recognized as infinite precision numbers. 
Please use rational input only as this improves the employed numerical methods. 
You can use Rationalize[input_,precision_]] where precision is the desired precision, e.g., 10^-100, to rationalize your numerical input."
	];
];


Options[GetLensingBand] := Join[
	Options[NDSolve],
	{
		PrintTemporaryOption->False,
		HorizonCondition->False,
		UseShadowBoundaryForEntryPoint -> True,
		ShowProgressPlot -> True,
		PlotRange -> MultipleOfEntryPoint,
		InitialBisectionPrecision->10^-3,
		MaxBisectionPrecision->10^-1,
		MaxNumberOfSteps -> \[Infinity],
		OutOfBoundsValue -> False,
		WhichLensingBand -> inner,
		WhichLensingBandNumber -> 1
	}
];

GetLensingBand[
		{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, 
		{{xCenterGuess_?RationalQ,yCenterGuess_?RationalQ}, {xOuterGuess_?RationalQ,yOuterGuess_?RationalQ}}, 
		paramRules_,
		opts:OptionsPattern[]
	] := Module[
	{
		inits, xScreen, yScreen, odes,
		\[Lambda]Max= 3rCam,
		shadowBoundary, 
		boundaryPoints = {},
		initUnit, initNormal,
		innerGuess, outerGuess,
		precisionAim, ringNumber, initialStepSize, minStepSize,
		decreasePrecisionFactor = 1.1
	}
	,
	(*check option value for precision aim*)
	precisionAim = If[
		NumberQ[OptionValue[InitialBisectionPrecision]]&&OptionValue[InitialBisectionPrecision]>0,
		OptionValue[InitialBisectionPrecision],
		Print["Option value for InitialBisectionPrecision must be a positive number."];
		Return[];
	];
	(*fix the minStepSize to the precision aim*)
	minStepSize = 4*precisionAim;
	
	ringNumber = If[
		IntegerQ[OptionValue[WhichLensingBandNumber]]&&OptionValue[WhichLensingBandNumber]>=0,
		OptionValue[WhichLensingBandNumber],
		Print["Option value for WhichLensingBandNumber must be an integer and \[GreaterEqual]0."];
		Return[];
	];
	
	(*prepare the ode system*)
	Switch[
		(*condition*)
		WhichCoords,
		(*option 1*)
		BoyerLindquist,
		odes = GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.Rationalize[paramRules,precisionAim*10^-100];
		inits = GetBoyerLindquistInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},0]/.Rationalize[paramRules,precisionAim*10^-100];
		,
		(*option 2*)
		Kerr,
		odes = GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}/.Rationalize[paramRules,precisionAim*10^-100];
		inits = GetKerrInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},$spin]/.Rationalize[paramRules,precisionAim*10^-100];
		,
		(*default other*)
		_,
		Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];
		Return[Null]		
	];
	
	(*check whether and if so use shadow boundary to determine entry point*)
	If[
		OptionValue[UseShadowBoundaryForEntryPoint]
		,
		shadowBoundary = Quiet@BoundaryBisectionInternal[
			odes, inits, {\[Lambda],0,\[Lambda]Max}, {xScreen, yScreen}, 
			{{xCenterGuess,yCenterGuess},{xOuterGuess,yOuterGuess}}, 
			paramRules, precisionAim*10^-1,
			Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[BoundaryBisectionInternal][[All,1]],optName]]]
		];
	];

	(*find first inner lensing-band point*)
	AppendTo[
		boundaryPoints, 
		LensingBandBisectionInternal[
			odes, inits, {\[Lambda],0,\[Lambda]Max}, {xScreen, yScreen},
			Switch[
				OptionValue[WhichLensingBand]
				,
				inner
				,
				PrintTemporary["Using ..."];
				Rationalize[
					{
						PrintTemporary[
							"\t... (i) user-specified ", 
							N@{xCenterGuess,yCenterGuess},
							" as inner guess, and ..."
						];
						{xCenterGuess,yCenterGuess}
						, 
						If[
							OptionValue[UseShadowBoundaryForEntryPoint]
							,
							PrintTemporary[
								"\t... (ii) shadow boundary at ", 
								N@shadowBoundary,
								" as outer guess ..."
							];
							PrintTemporary["... to determine entry point for inner lensing band."];
							shadowBoundary
							,
							PrintTemporary[
								"\t... (ii) user-specified ", 
								N@{xOuterGuess,yOuterGuess},
								" as outer guess ..."
							];
							PrintTemporary["... to determine entry point for inner lensing band."];
							{xOuterGuess,yOuterGuess}
						]
					}, 
					precisionAim*10^-100
				]
				,
				outer
				,
				PrintTemporary["Using ..."];
				Rationalize[
					{
						PrintTemporary[
							"\t... (i) user-specified ", 
							N@{xOuterGuess,yOuterGuess},
							" as outer guess and ..."
						];
						{xOuterGuess,yOuterGuess}
						, 
						If[
							OptionValue[UseShadowBoundaryForEntryPoint]
							,
							PrintTemporary[
								"\t... (ii) shadow boundary at ", 
								N@shadowBoundary,
								" as inner guess ..."
							];
							shadowBoundary
							,
							PrintTemporary[
								"\t... (ii) user-specified ", 
								N@{xCenterGuess,yCenterGuess},
								" as inner guess ..."
							];
							PrintTemporary["... to determine entry point for outer lensing band."];
							{xCenterGuess,yCenterGuess}
						]
					}, 
					precisionAim*10^-100
				]
				,
				___
				,
				Print["Option WhichLensingBand must either be 'inner' or 'outer'."];
				Break[];
			]
			, 
			paramRules, ringNumber, precisionAim, 
			Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[LensingBandBisectionInternal][[All,1]],optName]]]
		]
	];
	
	PrintTemporary["Entry point determined at ",boundaryPoints[[-1]],"."];
	
	(*move forward outer point by minStepSize along normal to vector between centerGuess and the first boundary point*)
	initUnit = (boundaryPoints[[-1]] - {xCenterGuess,yCenterGuess});
	initNormal = Reverse[initUnit]*{-1,1};
	initUnit = initUnit*minStepSize/Norm[initUnit];
	initNormal = initNormal*minStepSize/Norm[initNormal];
	
	(*find a second lensing-band point*)
	AppendTo[
		boundaryPoints, 
		LensingBandBisectionInternal[
			odes, inits, {\[Lambda],0,\[Lambda]Max}, {xScreen, yScreen}, 
			Switch[
				OptionValue[WhichLensingBand]
				,
				inner
				,
				Rationalize[{boundaryPoints[[-1]] - initUnit, boundaryPoints[[-1]] + initUnit + initNormal}, 10^-100]
				,
				outer
				,
				Rationalize[{boundaryPoints[[-1]] + initUnit + initNormal, boundaryPoints[[-1]] - initUnit}, 10^-100]
			], 
			paramRules, ringNumber, precisionAim, 
			Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[LensingBandBisectionInternal][[All,1]],optName]]]
		]
	];
	
	(*now we have two initial points to call FreeFloatingBisectionInnerLensingBandInternal*)
	Switch[
		OptionValue[WhichLensingBand]
		,
		inner
		,
		innerGuess = boundaryPoints[[-1]] - initUnit;
		outerGuess = boundaryPoints[[-1]] + initUnit + initNormal;
		,
		outer
		,
		innerGuess = boundaryPoints[[-1]] + initUnit + initNormal;
		outerGuess = boundaryPoints[[-1]] - initUnit;
	];
	
	DynamicModule[
		{
			stepCounter = 2,
			plotRange = If[
				OptionValue[PlotRange]===MultipleOfEntryPoint, 
				{{-1,1},{-1,1}}*Norm@boundaryPoints[[1]]*2,
				OptionValue[PlotRange]
			],
			plotFrame, plot
		}
		,
		(*if desired prepare progress plot*)
		If[
			OptionValue[ShowProgressPlot]
			,
			(*set the plot frame*)
			plotFrame = ListPlot[
				{},
				PlotRange -> plotRange,
				FrameLabel->{"x","y"},
				LabelStyle->{16,Black},
				ImageSize->400,AspectRatio->1,
				GridLines->{Table[ii,{ii,-100,100,5}],Table[ii,{ii,-100,100,5}]}, 
				GridLinesStyle->Directive[Thin,Lighter@Lighter@Lighter@Lighter@Gray],
				Frame->True, Axes->False, FrameStyle->Directive[Black],
				FrameTicks->Automatic
			];
			(*set and print initial version of the plot*)
			plot = Show[
				plotFrame,
				ListPlot[
					boundaryPoints,
					Joined->True, PlotRange->Full, PlotStyle->{{Gray}}
				],
				ListPlot[{innerGuess},PlotStyle->{{Blue}}],
				ListPlot[{outerGuess},PlotStyle->{{Red}}]
			];
			PrintTemporary[Dynamic@plot];
		];
		
		(*iterate until stop criterion is met*)
		While[
			Or[
				Length@boundaryPoints<10, 
				(*take at least 10 steps*)
				And[
					(*stop when the new boundary point is no longer a number*)
					NumberQ@Norm[boundaryPoints[[-1]]], 
					(*stop when boundary is closed*)
					Norm[boundaryPoints[[-1]] - boundaryPoints[[1]]] > Norm[boundaryPoints[[-2]] - boundaryPoints[[-1]]] + precisionAim,
					(*stop when MaxNumberOfSteps is reached*)
					If[
						IntegerQ@OptionValue[MaxNumberOfSteps]&&OptionValue[MaxNumberOfSteps]>0
						,
						Length@boundaryPoints<OptionValue[MaxNumberOfSteps]
						,
						True
					],
					(*stop when OutOfBoundsValue is reached*)
					If[
						NumberQ@OptionValue[OutOfBoundsValue]
						,
						Max[Abs@boundaryPoints[[-1]]]<OptionValue[OutOfBoundsValue]
						,
						True
					]
				]
			]
			,
			(*take one step and potentially upate the precisionAim*)
			{boundaryPoints, innerGuess, outerGuess, precisionAim} = FreeFloatingBisectionInnerLensingBandStep[
				odes, inits, {\[Lambda], 0, \[Lambda]Max}, {xScreen, yScreen}, 
				{innerGuess, outerGuess}, 
				boundaryPoints,
				paramRules, ringNumber, precisionAim, 
				minStepSize,
				Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[FreeFloatingBisectionInnerLensingBandStep][[All,1]],optName]]]
			];
			(*relax up to a maximum precision*)
			If[
				TrueQ[precisionAim<OptionValue[MaxBisectionPrecision]],
				precisionAim = decreasePrecisionFactor*precisionAim;
			];
			(*also update the minStepSize*)
			minStepSize = 4*precisionAim;
			
			(*if desired, update plot*)
			If[
				OptionValue[ShowProgressPlot]
				,
				stepCounter++;
				plot = Show[
					plotFrame,
					ListPlot[
						boundaryPoints,
						Joined->True, PlotRange->Full, PlotStyle->{{Gray}}
					],
					ListPlot[{innerGuess},PlotStyle->{{Blue}}],
					ListPlot[{outerGuess},PlotStyle->{{Red}}],
					Epilog->{
						Inset[
							Rotate[Style["number of steps: "<>ToString@stepCounter,Black,16],0],
							{0,If[NumberQ@First@Flatten@plotRange, Abs[First@Flatten@plotRange]*0.9, 0]},
							{Center,Top}
						]
					}
				];
			];
		];
		(*if desired, display final plot*)
(*		If[
			OptionValue[ShowProgressPlot]
			,
			Print[plot];
		];*)
	];
	Return@boundaryPoints;
];


Options[FreeFloatingBisectionInnerLensingBandStep] := Join[{PrintTemporaryOption->True, HorizonCondition->False},Options[NDSolve]];

FreeFloatingBisectionInnerLensingBandStep[
		odes_, inits_, {\[Lambda]_,\[Lambda]Min_,\[Lambda]Max_}, {xScreen_, yScreen_}, 
		{inner_List/;Length@inner==2, outer_List/;Length@outer==2}, 
		boundaryPoints_List/;Length@boundaryPoints>=2,
		paramRules_, ringNumber_, precisionAim_, minStepSize_,
		opts:OptionsPattern[]
	] := Module[
	{
		prev = boundaryPoints[[-1]],
		prevPrev = boundaryPoints[[-2]],
		tangent, innerToOuter, projection,
		new=0,
		innerNew=0, outerNew=0,
		boundaryPointsNew,
		testPlot1, testPlot2,
		internalPrecisionAim = precisionAim,
		increasePrecisionFactor = 2
	}
	,
	(*determine the prev vector tangent to the boundary*)
	tangent = (prev - prevPrev)Sqrt[2];
	
	(*ensure minimal stepsize*)
	If[
		Norm[tangent]<minStepSize, 
		tangent = tangent*minStepSize/Norm[tangent]
	];
	
	(*
		check that the NEW boundary lies between the points moved forward
		--------------------------
		To do so, we make sure that the bisection does not converge to innerNew or outerNew,
		since this signals that one of the lensing band edges has been crossed.
		(Presumably the one that is NOT being determined.)
		If so, decrease step size and try again.
	*)
	While[
		Or[
			Norm[innerNew-new]<=internalPrecisionAim*increasePrecisionFactor,
			Norm[outerNew-new]<=internalPrecisionAim*increasePrecisionFactor
		]
		,
		
		(*vector pointing from inner to outer*)
		innerToOuter = (outer - inner);
		innerToOuter = innerToOuter*Norm[tangent]/Norm[innerToOuter];
		
		(*balance out inner and outer around tangent*)
		(*NOTE: from previous bisection inner, prev, and outer must lie on a line*)
		innerNew = prev - innerToOuter/2;
		outerNew = prev + innerToOuter/2;
		innerToOuter = (outerNew - innerNew);
		
		(*project tangent onto vector pointing from inner to outer bisection point*)
		projection = innerToOuter.tangent;
	
		(*ensure that the PROJECTED boundary lies between the points moved forward*)
		If[
			Norm[innerNew - prev] < Norm[tangent],
			innerNew = innerNew - innerToOuter
		];
		If[
			Norm[outerNew - prev] < Norm[tangent],
			outerNew = outerNew + innerToOuter
		];
	
		(*if projection is positive (negative) move forward outer (inner) bisection point*)
		If[
			projection > 0
			,
			innerNew = innerNew + tangent;
			outerNew = outerNew;
			,
			innerNew = innerNew;
			outerNew = outerNew + tangent;
		];
		
		(*perform bisection to get the next point on the boundary*)
		new = LensingBandBisectionInternal[
			odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, 
			Rationalize[{innerNew, outerNew},10^-100], 
			paramRules, ringNumber, internalPrecisionAim, 
			opts
		];
		
		(*half the tangent in case while proceeds*)
		tangent = tangent/increasePrecisionFactor;
		internalPrecisionAim = internalPrecisionAim/increasePrecisionFactor
	];
	
	(*add new point to the list and return*)
	boundaryPointsNew = Append[boundaryPoints,new];	
	Return[{boundaryPointsNew,innerNew,outerNew,internalPrecisionAim*increasePrecisionFactor}]
];


Options[LensingBandBisectionInternal] := Join[{PrintTemporaryOption->True, HorizonCondition->False},Options[NDSolve]];

LensingBandBisectionInternal[odes_, inits_, {\[Lambda]_,\[Lambda]Min_,\[Lambda]Max_}, {xScreen_, yScreen_}, {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}}, paramRules_, ringNumber_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		sol,
		count
	},
	If[OptionValue[PrintTemporaryOption], 
		PrintTemporary["current inner lensing-band bisection: x \[Element] [",N@xInnerScreen,", ",N@xOuterScreen,"] and y \[Element] [",N@yInnerScreen,", ",N@yOuterScreen,"]."];
	];
	If[
		(xOuterScreen-xInnerScreen)^2 + (yOuterScreen-yInnerScreen)^2 > precisionAim^2
		,
		count = -1;
		sol = Check[
			Catch[NDSolve[
				Join[
					odes,
					inits/.{xScreen -> xInnerScreen + (xOuterScreen-xInnerScreen)/2, yScreen -> yInnerScreen + (yOuterScreen-yInnerScreen)/2}
				],
				{x[1][\[Lambda]],x[2][\[Lambda]],x[3][\[Lambda]],x[4][\[Lambda]],k[1][\[Lambda]],k[2][\[Lambda]],k[3][\[Lambda]],k[4][\[Lambda]]},{\[Lambda],\[Lambda]Min,\[Lambda]Max},
				Method -> If[
					TrueQ[!OptionValue[HorizonCondition]]
					,
					{
						"EventLocator", 
						"Event" -> {
							(* 1) check for increasing piercing number*)
							(Evaluate[(Mod[\[Pi]/2 + x[3][\[Lambda]], \[Pi]]==0)/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})
						}, 
						"EventAction" :> {
							(
								count = count + 1;
								If[OptionValue[PrintTemporaryOption],PrintTemporary["lensing-band count increased to ",N@count," at radius r=",N@x[2][\[Lambda]]] ];
							)
						},
						"Method"->{
							"ExplicitRungeKutta","Coefficients"->"EmbeddedExplicitRungeKuttaCoefficients",
							"DifferenceOrder"->5, "StiffnessTest"->True
						}
					}
					,
					{
						"EventLocator", 
						"Event" -> {
							(* 1) check for increasing piercing number*)
							(Evaluate[(Mod[\[Pi]/2 + x[3][\[Lambda]], \[Pi]]==0)/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})
							,
							(* 2) check for horizon *)
							(Evaluate[(OptionValue[HorizonCondition])/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})
						}, 
						"EventAction" :> {
							(
								count = count + 1;
								If[OptionValue[PrintTemporaryOption],PrintTemporary["lensing-band count increased to ",N@count," at radius r=",N@x[2][\[Lambda]]] ];
							)
							,
							(
								If[OptionValue[PrintTemporaryOption],PrintTemporary[
									"trajectory fell into user-defined horizon: at \[Lambda]="<>ToString[N[\[Lambda],5]]<>" the user-defined HorizonCondition has been numerically detected.",
									"Note that this essentially detects the observers image of the user-defined surface 'HorizonCondition'."
								]];
								Message[BoundaryBisectionInternal::HorizonCondition];
								Throw[Null,"StopIntegration"]
							)
						},
						"Method"->{
							"ExplicitRungeKutta","Coefficients"->"EmbeddedExplicitRungeKuttaCoefficients",
							"DifferenceOrder"->5, "StiffnessTest"->False
						}
					}
				],
				Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[NDSolve][[All,1]],optName]]], MaxSteps->OptionValue[MaxSteps]
			]],
			Null
		];
		
		If[
			count>=ringNumber,
			LensingBandBisectionInternal[odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen,yInnerScreen}, {xInnerScreen + (xOuterScreen-xInnerScreen)/2,yInnerScreen + (yOuterScreen-yInnerScreen)/2}}, paramRules, ringNumber, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]],
			LensingBandBisectionInternal[odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen + (xOuterScreen-xInnerScreen)/2,yInnerScreen + (yOuterScreen-yInnerScreen)/2}, {xOuterScreen,yOuterScreen}}, paramRules, ringNumber, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]]
		]
		,
		Return[N[{xInnerScreen + (xOuterScreen-xInnerScreen)/2, yInnerScreen + (yOuterScreen-yInnerScreen)/2}]]
		,
		None
	]
];


Options[GetLBRegion] := {NumberOfPolygonPoints->Automatic};

GetLBRegion[lbInner_List(*/;Dimensions@lbInner\[Equal]{_,2}*), lbOuter_List(*/;Dimensions@lbInner\[Equal]{_,2}*),opts:OptionsPattern[]] := Module[
	{
		nPolygon = OptionValue[NumberOfPolygonPoints]
		,
		lineInner,lineOuter
	}
	,
	(*lineInner = Line[lbInner[[1;;-1;;If[NumberQ@nPolygon,Min[Ceiling@Abs@(Length@Evaluate@lbInner/Re@nPolygon),Length@Evaluate@lbInner/4],1,1]]]];
	lineOuter = Line[lbOuter[[1;;-1;;If[NumberQ@nPolygon,Min[Ceiling@Abs@(Length@Evaluate@lbOuter/Re@nPolygon),Length@Evaluate@lbOuter/4],1,1]]]];
	Region@BoundaryDiscretizeGraphics@FilledCurve[
		{
		{lineInner},
		{lineOuter}
		}
	]*)
	RegionDifference[
		BoundaryMeshRegion[
			lbOuter,
			Line[Join[Table[ii,{ii,Length@lbOuter}],{1}]]
		],
		BoundaryMeshRegion[
			lbInner,
			Line[Join[Table[ii,{ii,Length@lbInner}],{1}]]
		]
	]
]


GetRangeOfRegion[reg_?RegionQ] := Module[
	{
		mesh = MeshCoordinates@BoundaryDiscretizeRegion@reg,
		xVals,yVals,
		xMin,xMax,yMin,yMax
	}
	,
	xVals = mesh[[All,1]];
	yVals = mesh[[All,2]];
	xMin = Min[xVals];
	xMax = Max[xVals];
	yMin = Min[yVals];
	yMax = Max[yVals];
	
	Return[{{xMin,xMax},{yMin,yMax}}]
]


ShiftedAndRescaledRegion[region_?RegionQ, {x_?NumberQ,y_?NumberQ,s_?NumberQ}]:=TransformedRegion[
	TransformedRegion[
		region
		,
		TranslationTransform[{x,y}]
	],
	(*absoute value such that minimization cannot mirror the region*)
	ScalingTransform[{Abs@s,Abs@s}]
];


AreaOfDifference[regToCover_?RegionQ, regToRescale_?RegionQ, {x_?NumberQ,y_?NumberQ,s_?NumberQ}]:=Module[
	{
		regRescaled = ShiftedAndRescaledRegion[regToRescale, {x,y,s}],
		area
	}
	,
	(*determine the area of regToCover where not covered by regRescaled*)
	area = Area[RegionDifference[regToCover,regRescaled]];
	(*devide by the area of the full region to be covered*)
	(*area = area / Area[regToCover];*)
	
	Return@area;
]


Options[GetMinimizedOverlap] := Options[GetLensingBand];

GetMinimizedOverlap[
	camera_List,
	params_List,
	LBexp_?RegionQ,
	opts:OptionsPattern[]
]:=Block[
	{
		(*random initial image vector along which to perform the first bisection*)
		initialBisectionGuess = Rationalize[
			{
				{0,0}, 
				(*{20,2}*)Evaluate[(100*#)/Norm[#]&@{RandomReal[{-1,1}],RandomReal[{-1,1}]}]
			},
			10^-10
		],
		(*diameter of the "observed" lensed-emission region*)
		diameterOfLBexp = (Max[#]-Min[#])&@(MeshCoordinates[LBexp][[All,1]]),
		LBinner, LBouter, LBregion,
		timing, minValue, minRule
	}
	,
	(*TODO: input validation*)
	(*TODO: validate theoretical consistency (horizon, and so on) for params*)
	
	(*GET INNER LENSING BAND*)
	Print["inner lensing band bisection in progress ..."];
	timing = First@Timing[
		LBinner = Quiet@GetLensingBand[
			camera,
			initialBisectionGuess,
			params,
			WhichLensingBand->inner,
			PrintTemporaryOption->False,
			opts
		];
	];
	Print["... for ",timing," sec."];
	
	(*GET OUTER LENSING BAND*)
	Print["outer lensing band bisection in progress ..."];
	timing = First@Timing[
		LBouter = Quiet@GetLensingBand[
			camera,
			initialBisectionGuess,
			params,
			WhichLensingBand->outer,
			PrintTemporaryOption->False,
			opts
		];
	];
	Print["... for ",timing," sec."];
	
	(*MINIMIZE OVERLAPPING REGION*)
	LBregion = GetLBRegion[
		LBinner,
		LBouter
	];
	Print["minimization in progress ..."];
	timing = First@Timing[
		{minValue, minRule} = NMinimize[
				{AreaOfDifference[LBexp,LBregion, {x,y,1}]/Area[LBexp], x^2+y^2<=(diameterOfLBexp/2)^2},
				{x,y},
				Method->"RandomSearch"
			];];
	minValue = 1-minValue;
	Print["... for ",timing," sec."];
	
	(*TODO: output control*)
	Return[{minValue,minRule,LBregion}];
];


texStyle = {FontFamily -> "Latin Modern Roman", FontSize -> 16, FontColor->Black};


Options[GetPlotFrameLeft] = Option[ListPlot];

GetPlotFrameLeft[plotRange_List/;Dimensions@plotRange==={2,2},opts:OptionsPattern[]] := Module[
	{
		range = Max@Abs@Flatten[plotRange]
	}
	,
	ListPlot[
		{},
		opts,
		BaseStyle -> texStyle,
		PlotRange -> plotRange,
		FrameLabel->None(*{
			MaTeX["x_\\text{im}\;\;[M]"],
			MaTeX["y_\\text{im}\;\;[M]"]
		}*),
		LabelStyle->{16,Black},
		ImageSize->{UpTo[1000],UpTo[200]},AspectRatio->1,
		GridLines->{
			Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}],
			Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}]
		}, 
		GridLinesStyle->Directive[Thin,Lighter@Lighter@Lighter@Lighter@Gray],
		Frame->True, Axes->False, FrameStyle->Directive[Black],
		FrameTicks->{
			{Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}],None},
			{Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}],None}
		}, 
		FrameTicksStyle->Directive[Black,12]
	]
];


Options[GetPlotFrameRight] = Option[ListPlot];

GetPlotFrameRight[plotRange_List/;Dimensions@plotRange==={2,2},opts:OptionsPattern[]] := Module[
	{
		range = Max@Abs@Flatten[plotRange]
	}
	,
	ListPlot[
		{},
		opts,
		BaseStyle -> texStyle,
		PlotRange -> plotRange,
		FrameLabel->None,
		LabelStyle->{16,Black},
		ImageSize->{UpTo[1000],UpTo[200]},AspectRatio->1,
		GridLines->{
			Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}],
			Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}]
		}, 
		GridLinesStyle->Directive[Thin,Lighter@Lighter@Lighter@Lighter@Gray],
		Frame->True, Axes->False, FrameStyle->Directive[Black],
		FrameTicks->{
			{None,Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}]},
			{Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}],None}
		}, 
		FrameTicksStyle->Directive[Black,12]
	]
];



Options[GetPlotFrameMiddle] = Option[ListPlot];

GetPlotFrameMiddle[plotRange_List/;Dimensions@plotRange==={2,2},opts:OptionsPattern[]] := Module[
	{
		range = Max@Abs@Flatten[plotRange]
	}
	,
	ListPlot[
		{},
		opts,
		BaseStyle -> texStyle,
		PlotRange -> plotRange,
		FrameLabel->None,
		LabelStyle->{16,Black},
		ImageSize->{UpTo[1000],UpTo[200]},AspectRatio->1,
		GridLines->{
			Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}],
			Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}]
		}, 
		GridLinesStyle->Directive[Thin,Lighter@Lighter@Lighter@Lighter@Gray],
		Frame->True, Axes->False, FrameStyle->Directive[Black],
		FrameTicks->{
			{None,None},
			{Table[ii,{ii,-Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range],Power[10,Ceiling@RealExponent@range]/10}],None}
		}, 
		FrameTicksStyle->Directive[Black,12]
	]
];



Options[OverlayLensingBandsByHand] := Join[
	Options@ListPlot,
	{
		ScaleRange->{0.1,3},
		InitsXYS->{0,0,1},
		LB1Color->Opacity[0.2,Darker@RGBColor["#0070ff"]],
		LB2Color->Opacity[0.5,RGBColor["#ff8f00"]]
	}
];

OverlayLensingBandsByHand[lb1_,lb2_,opts:OptionsPattern[]] := Module[
	{
		scaleMin = If[NumberQ@#,#,0.1]&@First[OptionValue[ScaleRange]],
		scaleMax = If[NumberQ@#,#,3]&@Last[OptionValue[ScaleRange]],
		range,
		plotRange,
		plotFrameLeft
	}
	,
	(*determine the plot range*)
	range = Max@Abs@Join[First@GetRangeOfRegion[lb1],First@GetRangeOfRegion[lb2]]*scaleMax;
	plotRange = {{-range,range},{-range,range}};
	
	(*generate a plot frame*)
	plotFrameLeft = GetPlotFrameLeft[plotRange,opts,FrameLabel->{"x","y"},ImageSize->300];
	
	Manipulate[
	Column[{
		Show[
			plotFrameLeft,
			Graphics[{
				OptionValue[LB1Color],
				BoundaryDiscretizeRegion@lb1
			}],
			Graphics[{
				OptionValue[LB2Color],
				BoundaryDiscretizeRegion@Region@TransformedRegion[
					TransformedRegion[
						lb2
						,
						TranslationTransform[{x,y}]
					],
					ScalingTransform[{s,s}]
				]
			}]
		],
		"displacement x = "<>ToString@N@x,
		"displacement y = "<>ToString@N@y,
		"rescaling s = "<>ToString@N@s
	}],
	{{x,OptionValue[InitsXYS][[1]],"displacement x"},-(range/2),range/2}, 
	{{y,OptionValue[InitsXYS][[2]],"displacement y"},-(range/2),range/2}, 
	{{s,OptionValue[InitsXYS][[3]],"rescaling s"},scaleMin,scaleMax},
	ContentSize->UpTo[1000]
]
]


End[];


EndPackage[];
